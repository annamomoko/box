<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jost:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <title>Abstract Fish Swimming</title>
  <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: none;
        }
        
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .status {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #ffd700;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .camera-status {
            position: absolute;
            top: 100px;
            left: 20px;
            color: #87ceeb;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .debug-info {
            position: absolute;
            top: 130px;
            left: 20px;
            color: #90ee90;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .camera-selector {
            position: absolute;
            top: 160px;
            left: 20px;
            z-index: 10;
        }
        
        .camera-selector select {
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid #87ceeb;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 12px;
            font-family: Arial, sans-serif;
        }

        /* Analyze UI */
        .analyze-ui {
            position: absolute;
            top: 200px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .analyze-ui button {
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(2px);
        }
        .analyze-ui button:hover { background: rgba(0,0,0,0.7); }
        .fullness-output { color: #ffd700; white-space: pre-line; font-size: 14px; }

        /* Snapshot preview */
        .snapshot-wrapper {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 12;
        }
        #snapshot { max-width: 360px; display: none; border: 2px solid rgba(255,255,255,0.4); border-radius: 6px; }
        #snapshotOverlay { position: absolute; left: 0; top: 0; display: none; pointer-events: none; }
        
        .camera-selector select:focus {
            outline: none;
            border-color: #ffd700;
        }
        


        /* Theme buttons (top-left) */
        .theme-buttons {
            position: absolute;
            top: 10px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        .theme-buttons button {
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(2px);
        }

        .theme-buttons button:hover {
            background: rgba(0,0,0,0.7);
        }

        /* Hand detection counter */
        .hand-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            color: #ffffff; /* simple white text */
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            font-size: 14px;
        }

        /* Center screen ephemeral message */
        .center-message {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60; /* above other UI */
            pointer-events: none;
        }
        .center-message .text {
            max-width: 72vw;
            text-align: center;
            color: #ffffff;
            font-family: "Jost", sans-serif;
            font-optical-sizing: auto;
            font-weight: 300;
            font-style: normal;
            line-height: 1.35;
            letter-spacing: 0.6px;
            font-size: clamp(18px, 2.1vw, 28px);
            opacity: 0;
            display: inline-block;
            will-change: transform, opacity;
        }
        .center-message .text.show { animation: centerFade 8s ease-out forwards; }
        /* When ripple class is present, run both fade and ripple simultaneously */
        .center-message .text.show.ripple { animation: centerFade var(--fade-dur, 15s) ease-out forwards, ripple 12s ease-in-out 1; }
        .center-message .text.boost { transform: scale(1.22); }
        .center-message .text.ripple { animation: ripple 12s ease-in-out 1; }
        .center-message .word { display: inline-block; white-space: pre; }
        .center-message .word.fly { animation: wordFly var(--fly-dur, 3s) ease-in forwards; animation-delay: var(--fly-delay, 0s); }
        @keyframes centerFade { from { opacity: 1; } to { opacity: 0; } }
        @keyframes ripple {
            0% { transform: translateY(0) scale(1); }
            15% { transform: translateY(-2px) scale(1.01); }
            30% { transform: translateY(1px) scale(1); }
            45% { transform: translateY(-1px) scale(1.01); }
            60% { transform: translateY(1px) scale(1); }
            75% { transform: translateY(-0.5px) scale(1.005); }
            100% { transform: translateY(0) scale(1); }
        }
        @keyframes wordFly {
            0% { opacity: 1; transform: translate(0, 0) rotate(0deg); filter: blur(0); }
            100% { opacity: 0; transform: translate(var(--tx, 0), var(--ty, 0)) rotate(var(--rot, 0deg)); filter: blur(1px); }
        }

        /* Hide UI helper */
        .hidden-ui .instructions,
        .hidden-ui .status,
        .hidden-ui .camera-status,
        .hidden-ui .debug-info,
        .hidden-ui .camera-selector,
        .hidden-ui .theme-buttons,
        .hidden-ui .analyze-ui,
        .hidden-ui .snapshot-wrapper,
        .hidden-ui #video {
            display: none !important;
        }
  </style>
</head>
<body class="hidden-ui">
    <div class="theme-buttons" id="theme-buttons">
        <button id="btn-blue" title="Blue Gradient">Blue</button>
        <button id="btn-green" title="Green → Yellow">Green-Yellow</button>
        <button id="btn-orange" title="Orange → Red">Orange-Red</button>
    </div>
    <div class="instructions">Press 'D' for left, 'L' for right, 'K' for all — or show your hand!</div>
    <div class="status" id="status">Fish swimming in formation</div>
    <div class="camera-status" id="camera-status">Camera: Initializing...</div>
    <div class="debug-info" id="debug-info">Hand detection: Inactive</div>
    <div class="camera-selector" id="camera-selector" style="display: none;">
        <select id="camera-select">
            <option value="">Select Camera...</option>
        </select>
    </div>

    <div class="analyze-ui">
        <button id="btn-analyze">Analyze Box Fullness</button>
        <div id="fullness-output" class="fullness-output"></div>
    </div>

    <div class="snapshot-wrapper">
        <img id="snapshot" />
        <canvas id="snapshotOverlay"></canvas>
    </div>

    <video id="video" style="position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid white; border-radius: 8px; z-index: 20;"></video>
    <canvas id="canvas"></canvas>
    <div id="hand-counter" class="hand-counter">0</div>
    <div id="center-message" class="center-message"><div class="text"></div></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const cameraStatus = document.getElementById('camera-status');
        const debugInfo = document.getElementById('debug-info');
        const video = document.getElementById('video');
        const cameraSelector = document.getElementById('camera-selector');
        const cameraSelect = document.getElementById('camera-select');
        const btnAnalyze = document.getElementById('btn-analyze');
        const fullnessOutput = document.getElementById('fullness-output');
        const snapshotImg = document.getElementById('snapshot');
        const snapshotCanvas = document.getElementById('snapshotOverlay');
        const snapshotCtx = snapshotCanvas.getContext('2d');
        const handCounterEl = document.getElementById('hand-counter');
        let handCount = 0;
		let appliedGreenThemeAt200 = false;
		let appliedOrangeThemeAt500 = false;

        // Center message refs
        const centerMessage = document.getElementById('center-message');
        const centerMessageText = centerMessage.querySelector('.text');

        const btnBlue = document.getElementById('btn-blue');
        const btnGreen = document.getElementById('btn-green');
        const btnOrange = document.getElementById('btn-orange');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Fish class (back to original simple design)
        class Fish {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 20 + 15;
                this.baseSpeed = Math.random() * 1.5 + 0.8;
                this.speed = this.baseSpeed;
                this.angle = Math.random() * Math.PI * 2;
                this.targetAngle = 0;
                this.scatterAngle = 0;
                this.color = this.generateColor();
                this.tail = [];
                this.maxTailLength = 8;
                this.swimOffset = Math.random() * Math.PI * 2;
                this.personalSpace = this.size * 3;
                this.isScattering = false;
                this.scatterSpeed = 0;
                this.scatterUntil = 0;
                this.growHighlightUntil = 0;
                this.growAnimStart = 0;
                this.growAnimDuration = 500; // ms
                this.growOvershoot = 0.3; // overshoot scale ~30% (more obvious)
				this.innerGlowUntil = 0; // when > now, render inner glow (stomach trash added)
				this.innerGlowStart = 0; // start time of inner glow
				this.innerGlowDuration = 1200; // total duration for blinking glow
            }
            
            getGrowScale(now) {
                const start = this.growAnimStart || 0;
                const duration = this.growAnimDuration || 0;
                if (!start || !duration) return 1;
                const tMs = now - start;
                if (tMs <= 0) return 1 + this.growOvershoot;
                const t = tMs / duration;
                if (t >= 1) return 1;
                const upPhase = 0.25; // first quarter time ramps to overshoot
                const easeOutCubic = (u) => 1 - Math.pow(1 - u, 3);
                if (t < upPhase) {
                    return 1 + this.growOvershoot * easeOutCubic(t / upPhase);
                } else {
                    const u = (t - upPhase) / (1 - upPhase);
                    return 1 + this.growOvershoot * (1 - easeOutCubic(u));
                }
            }
            
            generateColor() {
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', 
                    '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(isScattered, groupAngle, allFish) {
                // Store previous position for tail
                this.tail.unshift({x: this.x, y: this.y});
                if (this.tail.length > this.maxTailLength) {
                    this.tail.pop();
                }
                
                const activeScatter = isScattered || (Date.now() < this.scatterUntil);
                
                if (activeScatter) {
                    this.targetAngle = this.scatterAngle;
                    this.speed = this.scatterSpeed;
                    this.isScattering = true;
                } else {
                    if (this.isScattering) {
                        this.speed = this.baseSpeed;
                        this.isScattering = false;
                    }
                    
                    // Natural schooling behavior
                    let avgX = 0, avgY = 0, neighbors = 0;
                    let separationX = 0, separationY = 0;
                    let avgAngle = 0;
                    
                    // Check nearby fish for flocking behavior
                    allFish.forEach(other => {
                        if (other === this) return;
                        
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.personalSpace * 4) {
                            neighbors++;
                            avgX += other.x;
                            avgY += other.y;
                            avgAngle += other.angle;
                            
                            if (distance < this.personalSpace) {
                                separationX -= dx / distance;
                                separationY -= dy / distance;
                            }
                        }
                    });
                    
                    if (neighbors > 0) {
                        avgX /= neighbors;
                        avgY /= neighbors;
                        const cohesionAngle = Math.atan2(avgY - this.y, avgX - this.x);
                        avgAngle /= neighbors;
                        
                        let separationAngle = Math.atan2(separationY, separationX);
                        
                        this.targetAngle = 
                            groupAngle * 0.4 + 
                            cohesionAngle * 0.2 + 
                            avgAngle * 0.3 + 
                            separationAngle * 0.1 +
                            Math.sin(Date.now() * 0.002 + this.swimOffset) * 0.2;
                    } else {
                        this.targetAngle = groupAngle + Math.sin(Date.now() * 0.002 + this.swimOffset) * 0.3;
                    }
                }
                
                // Smooth angle transition
                let angleDiff = this.targetAngle - this.angle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                this.angle += angleDiff * (activeScatter ? 0.15 : 0.08);
                
                // Move fish with natural swimming motion
                const swimWave = Math.sin(Date.now() * 0.01 + this.swimOffset) * 0.2;
                this.x += Math.cos(this.angle + swimWave) * this.speed;
                this.y += Math.sin(this.angle + swimWave) * this.speed;
                
                // Wrap around screen
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.y > canvas.height + 50) this.y = -50;
            }
            
            draw() {
                ctx.save();
                const now = Date.now();
                const scale = this.getGrowScale(now);
                const drawSize = this.size * scale;
                
                // Draw tail
                for (let i = 0; i < this.tail.length; i++) {
                    const alpha = (this.tail.length - i) / this.tail.length * 0.3;
                    const size = drawSize * (0.3 + alpha);
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.tail[i].x, this.tail[i].y, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
					// Draw fish body
					ctx.fillStyle = this.color;
					ctx.beginPath();
					ctx.ellipse(0, 0, drawSize, drawSize * 0.6, 0, 0, Math.PI * 2);
					ctx.fill();

					// Inner glow to highlight stomach trash addition (blinks twice)
					if (now < this.innerGlowUntil) {
						ctx.save();
						const elapsed = Math.max(0, now - (this.innerGlowStart || now));
						const dur = this.innerGlowDuration || 1200;
						const u = Math.min(1, elapsed / dur);
						// Two blinks: use sin over 2 cycles with easing envelope
						const cycles = 2; // two flashes
						const wave = Math.max(0, Math.sin(u * Math.PI * cycles));
						const ease = 1 - Math.pow(1 - u, 2);
						const intensity = Math.pow(wave, 1.4) * (0.6 + 0.4 * (1 - u)) * ease;
						ctx.globalCompositeOperation = 'screen';
						ctx.globalAlpha = 0.35 + 0.55 * intensity;
						// More vibrant inner colors
						const grad = ctx.createRadialGradient(0, 0, drawSize * 0.04, 0, 0, drawSize * 0.9);
						grad.addColorStop(0, 'rgba(255, 120, 0, 1.0)');   // hot orange core
						grad.addColorStop(0.4, 'rgba(255, 220, 100, 0.9)'); // bright amber
						grad.addColorStop(1, 'rgba(255, 240, 170, 0)');     // soft falloff
						ctx.fillStyle = grad;
						ctx.beginPath();
						ctx.ellipse(0, 0, drawSize, drawSize * 0.6, 0, 0, Math.PI * 2);
						ctx.fill();
						// Emphasis ring that also pulses with the blink
						ctx.shadowColor = 'rgba(255, 200, 60, 1)';
						ctx.shadowBlur = 28 + 14 * intensity;
						ctx.lineWidth = Math.max(3, drawSize * (0.06 + 0.04 * intensity));
						ctx.strokeStyle = `rgba(255, 200, 60, ${0.4 + 0.5 * intensity})`;
						ctx.beginPath();
						ctx.ellipse(0, 0, drawSize * (0.65 + 0.06 * intensity), drawSize * 0.6 * (0.65 + 0.06 * intensity), 0, 0, Math.PI * 2);
						ctx.stroke();
						ctx.restore();
					}
                
                // Draw fish outline
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Growth highlight glow (temporary visual cue when size increases)
                if (now < this.growHighlightUntil) {
                    ctx.save();
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, drawSize, drawSize * 0.6, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(drawSize * 0.3, -drawSize * 0.1, drawSize * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(drawSize * 0.35, -drawSize * 0.1, drawSize * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw fins
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.7;
                
                // Top fin
                ctx.beginPath();
                ctx.moveTo(-drawSize * 0.2, -drawSize * 0.4);
                ctx.lineTo(drawSize * 0.2, -drawSize * 0.8);
                ctx.lineTo(drawSize * 0.6, -drawSize * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Bottom fin
                ctx.beginPath();
                ctx.moveTo(-drawSize * 0.2, drawSize * 0.4);
                ctx.lineTo(drawSize * 0.2, drawSize * 0.8);
                ctx.lineTo(drawSize * 0.6, drawSize * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Tail fin
                ctx.beginPath();
                ctx.moveTo(-drawSize * 0.8, -drawSize * 0.4);
                ctx.lineTo(-drawSize * 1.2, 0);
                ctx.lineTo(-drawSize * 0.8, drawSize * 0.4);
                ctx.lineTo(-drawSize * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            scatter() {
                this.scatterAngle = Math.random() * Math.PI * 2;
                this.scatterSpeed = this.baseSpeed * (2 + Math.random() * 2);
            }
        }
        
        // Water splash effects
        class WaterSplash {
            constructor(x, y, opts = {}) {
                this.x = x;
                this.y = y;
                this.particles = [];
                // introduce variants so not all splashes look the same
                this.variant = opts.variant || (Math.random() < 0.35 ? 'short' : (Math.random() < 0.5 ? 'spray' : 'normal'));
                
                // overall splash lifetime and decay, varied per variant
                if (this.variant === 'short') {
                    this.life = 0.8 + Math.random() * 0.2;
                    this.lifeDecay = 0.05 + Math.random() * 0.03;
                } else if (this.variant === 'spray') {
                    this.life = 1.0;
                    this.lifeDecay = 0.035 + Math.random() * 0.015;
                } else {
                    this.life = 1.0;
                    this.lifeDecay = 0.03 + Math.random() * 0.02;
                }
                
                // particle count, speed and size ranges per variant
                const particleCount = this.variant === 'short'
                    ? 8 + Math.floor(Math.random() * 6)
                    : this.variant === 'spray'
                        ? 18 + Math.floor(Math.random() * 10)
                        : 16 + Math.floor(Math.random() * 10);
                const speedRange = this.variant === 'spray' ? 14 : (this.variant === 'short' ? 8 : 12);
                const sizeMin = this.variant === 'short' ? 1 : (this.variant === 'spray' ? 1 : 3);
                const sizeMax = this.variant === 'short' ? 4 : (this.variant === 'spray' ? 6 : 8);
                
                // Create splash particles with per-particle decay variation
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * speedRange,
                        vy: (Math.random() - 0.5) * speedRange,
                        life: 0.7 + Math.random() * 0.6,
                        lifeDecay: (this.variant === 'short' ? 0.05 : 0.02) + Math.random() * 0.03,
                        size: Math.random() * (sizeMax - sizeMin) + sizeMin,
                        sizeDecay: 0.96 + Math.random() * 0.03
                    });
                }
            }
            
            update() {
                this.life -= this.lifeDecay;
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    // slight damping
                    p.vx *= 0.94;
                    p.vy *= 0.94;
                    // very subtle upward drift for "spray"
                    if (this.variant === 'spray') p.vy -= 0.03;
                    p.life -= p.lifeDecay;
                    p.size *= p.sizeDecay;
                });
                
                this.particles = this.particles.filter(p => p.life > 0 && p.size > 0.2);
                return this.life > 0 && this.particles.length > 0;
            }
            
            draw() {
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, Math.min(1, p.life)) * 0.6;
                    ctx.fillStyle = '#87ceeb';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = Math.max(0, Math.min(1, p.life)) * 0.3;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        }
        
        // Ripple effect
        class WaterRipple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 100 + Math.random() * 120;
                this.growth = 2 + Math.random() * 4;
                this.life = 1.0;
                this.lineWidth = 2 + Math.random() * 3;
                this.alpha = 0.2 + Math.random() * 0.2;
            }
            
            update() {
                this.radius += this.growth;
                this.life = 1 - (this.radius / this.maxRadius);
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha * Math.max(0, this.life);
                ctx.strokeStyle = '#87ceeb';
                ctx.lineWidth = this.lineWidth;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = this.alpha * 0.4 * Math.max(0, this.life);
                ctx.lineWidth = this.lineWidth * 1.8;
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Create fish school
        const fish = [];
        const fishCount = 25;
        const waterEffects = [];
        const trashItems = [];
        let trashAddCount = 3; // fixed items per 't' press
        let yellowTintStrength = 0; // 0..1, increases with 't'
        
        // Accumulating stomach trash per fish index
        const stomachTrashByFish = new Map(); // index -> TrashItem[]
        function randomBetween(min, max) { return min + Math.random() * (max - min); }
        function addRandomStomachTrashForFishIndex(index, itemsToAdd = 1) {
            if (index < 0 || index >= fish.length) return;
            const list = stomachTrashByFish.get(index) || [];
            for (let i = 0; i < itemsToAdd; i++) {
                const typeRand = Math.random();
                const type = typeRand < 0.3 ? 'ring' : typeRand < 0.6 ? 'shard' : typeRand < 0.85 ? 'chip' : 'cluster';
                list.push({
                    type,
                    offsetXScale: randomBetween(-0.08, 0.12), // relative to fish.size
                    offsetYScale: randomBetween(-0.05, 0.12),
                    sizeScale: randomBetween(0.18, 0.42),
                    rotation: randomBetween(-Math.PI, Math.PI),
                    colorA: Math.random() < 0.5 ? 'rgba(173, 216, 230, 0.9)' : 'rgba(255, 215, 0, 0.85)',
                    colorB: Math.random() < 0.5 ? 'rgba(255,255,255,0.9)' : 'rgba(46, 204, 113, 0.9)',
                    pulseSpeed: randomBetween(0.003, 0.007)
                });
            }
            stomachTrashByFish.set(index, list);
            // trigger visible inner glow on that fish
            const f = fish[index];
            if (f) {
                const now = Date.now();
                f.innerGlowStart = now;
                f.innerGlowDuration = 1400; // slightly longer to fit two blinks
                f.innerGlowUntil = now + f.innerGlowDuration;
            }
        }
        function addStomachTrashToTwoFish() {
            if (!Array.isArray(fish) || fish.length === 0) return;
            const indices = Array.from({ length: fish.length }, (_, i) => i);
            // prefer fish without any trash
            const clean = indices.filter(i => !stomachTrashByFish.has(i));
            const pool = clean.length >= 2 ? clean : indices;
            // shuffle pool
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = pool[i];
                pool[i] = pool[j];
                pool[j] = tmp;
            }
            const first = pool[0];
            let second = pool.find(i => i !== first);
            if (second == null) second = first; // degenerate single-fish case
            addRandomStomachTrashForFishIndex(first, 1);
            addRandomStomachTrashForFishIndex(second, 1);
        }
        
        // Effect helpers
        function randomEffectMode() {
            const r = Math.random();
            if (r < 1/3) return 'splash';
            if (r < 2/3) return 'ripple';
            return 'both';
        }
        function addWaterEffects(x, y, mode) {
            if (mode === 'splash') {
                waterEffects.push(new WaterSplash(x, y));
            } else if (mode === 'ripple') {
                waterEffects.push(new WaterRipple(x, y));
            } else {
                waterEffects.push(new WaterSplash(x, y));
                waterEffects.push(new WaterRipple(x, y));
            }
        }
        
        // Create fish in a more spread out formation
        for (let i = 0; i < fishCount; i++) {
            const angle = (i / fishCount) * Math.PI * 2;
            const radius = 100 + Math.random() * 200;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            fish.push(new Fish(
                centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 100,
                centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 100
            ));
        }
        
        // Grow half the fish by a small percentage
        function growHalfFishBy(percent) {
            if (!Array.isArray(fish) || fish.length === 0) return;
            const indices = Array.from({ length: fish.length }, (_, i) => i);
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = indices[i];
                indices[i] = indices[j];
                indices[j] = tmp;
            }
            const numToGrow = Math.floor(fish.length / 2);
            for (let k = 0; k < numToGrow; k++) {
                const f = fish[indices[k]];
                const newSize = f.size * (1 + percent);
                // Optional cap to avoid runaway growth
                f.size = Math.min(newSize, 120);
                f.personalSpace = f.size * 3;
                const now = Date.now();
                f.growHighlightUntil = now + 900; // ~0.9s glow
                f.growAnimStart = now; // start bounce animation
            }
        }
        
        // Game state
        let isScattered = false;
        let scatterTime = 0;
        let groupAngle = 0;
        let lastHandDetection = 0;
        let handDetectionCooldown = 3000; // 3 second cooldown
        let lastSideScatter = 0;
        const sideScatterCooldown = 1500; // debounce side-scatter to avoid rapid re-targeting
        
        // Hand detection variables
        let handDetectionEnabled = false;
        let baselineSet = false;
        let baselineSkinPixels = 0;
        let frameCount = 0;
        // Robustness helpers: EMA baseline and multi-frame confirmation
        let emaBaseline = 0;
        const emaAlpha = 0.05; // lower = smoother baseline
        let consecutiveHandFrames = 0;
        
        // Camera management variables
        let availableCameras = [];
        let currentStream = null;
        let selectedCameraId = null;
        
        let backgroundOverride = null; // 'blue' | 'green' | 'orange' | null
        let selectedTheme = 'blue';
        let forceRepaintBackground = true;
        const themeGradients = {
            blue: ['#1e3c72', '#2a5298'],
            green: ['#2e7d32', '#f9a825'],
            orange: ['#fb8c00', '#c62828']
        };
        
        // Enumerate available cameras
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                
                // Clear existing options
                cameraSelect.innerHTML = '<option value="">Select Camera...</option>';
                
                // Add cameras to selector
                availableCameras.forEach((camera, index) => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                // Show selector if multiple cameras available
                if (availableCameras.length > 1) {
                    cameraSelector.style.display = 'block';
                    cameraStatus.textContent = `Camera: ${availableCameras.length} cameras found - Select one below`;
                } else if (availableCameras.length === 1) {
                    // Auto-select if only one camera
                    selectedCameraId = availableCameras[0].deviceId;
                    startCamera(selectedCameraId);
                } else {
                    cameraStatus.textContent = 'Camera: No cameras found';
                }
                
                return availableCameras.length > 0;
            } catch (error) {
                console.error('Failed to enumerate cameras:', error);
                cameraStatus.textContent = 'Camera: Error accessing cameras';
                return false;
            }
        }
        
        // Start camera with specific device ID
        async function startCamera(deviceId) {
            try {
                // Stop current stream if exists
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                
                cameraStatus.textContent = 'Camera: Starting camera...';
                
                const constraints = {
                    video: { 
                        width: 320, 
                        height: 240,
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        facingMode: deviceId ? undefined : 'user'
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                video.play();
                
                selectedCameraId = deviceId;
                
                // Update selector to show selected camera
                if (deviceId && cameraSelect.value !== deviceId) {
                    cameraSelect.value = deviceId;
                }
                
                cameraStatus.textContent = 'Camera: Setting up hand detection...';
                
                // Wait for video to be ready, then start hand detection
                video.addEventListener('loadeddata', () => {
                    setTimeout(() => {
                        // Reset hand detection baseline for new camera
                        baselineSet = false;
                        frameCount = 0;
                        startHandDetection();
                        
                        const selectedCamera = availableCameras.find(cam => cam.deviceId === deviceId);
                        const cameraName = selectedCamera ? (selectedCamera.label || 'Unknown Camera') : 'Default Camera';
                        cameraStatus.textContent = `Camera: Active (${cameraName}) - Show hand to scatter fish!`;
                    }, 1000);
                });
                
            } catch (error) {
                console.error('Camera access failed:', error);
                cameraStatus.textContent = 'Camera: Failed to start - Use keyboard only';
                debugInfo.textContent = 'Hand detection: Disabled (camera error)';
            }
        }
        
        // Initialize camera system
        async function initializeCamera() {
            try {
                cameraStatus.textContent = 'Camera: Requesting permission...';
                
                // First, get permission to access cameras
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop()); // Stop immediately
                
                // Now enumerate cameras with proper labels
                await enumerateCameras();
                
            } catch (error) {
                console.error('Camera permission denied:', error);
                cameraStatus.textContent = 'Camera: Permission denied - Use keyboard only';
                debugInfo.textContent = 'Hand detection: Disabled (no permission)';
            }
        }
        
        function startHandDetection() {
            const detectionCanvas = document.createElement('canvas');
            const detectionCtx = detectionCanvas.getContext('2d');
            detectionCanvas.width = 160;
            detectionCanvas.height = 120;
            
            handDetectionEnabled = true;
            
            function detectHand() {
                if (!handDetectionEnabled || video.readyState !== video.HAVE_ENOUGH_DATA) {
                    requestAnimationFrame(detectHand);
        return;
      }

                frameCount++;
                detectionCtx.drawImage(video, 0, 0, detectionCanvas.width, detectionCanvas.height);
                
                // Get image data for analysis
                const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
                const data = imageData.data;
                
                // Analyze multiple regions for hand detection
                const regions = [
                    { x: 40, y: 30, w: 80, h: 60 },  // center
                    { x: 20, y: 20, w: 60, h: 50 },  // top-left
                    { x: 80, y: 20, w: 60, h: 50 },  // top-right
                    { x: 40, y: 50, w: 80, h: 50 }   // bottom-center
                ];
                
                let totalSkinPixels = 0;
                let handLikeRegions = 0;
                
                regions.forEach(region => {
                    let skinPixels = 0;
                    let totalPixels = 0;
                    let skinClusters = 0;
                    
                    for (let y = region.y; y < region.y + region.h && y < detectionCanvas.height; y++) {
                        for (let x = region.x; x < region.x + region.w && x < detectionCanvas.width; x++) {
                            const i = (y * detectionCanvas.width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            if (isImprovedSkinTone(r, g, b)) {
                                skinPixels++;
                            }
                            totalPixels++;
                        }
                    }
                    
                    const skinRatio = skinPixels / totalPixels;
                    totalSkinPixels += skinPixels;
                    
                    // A region is "hand-like" if it has a good concentration of skin pixels
                    if (skinRatio > 0.25 && skinPixels > 200) {
                        handLikeRegions++;
                    }
                });
                
                // Set baseline after first 30 frames
                if (!baselineSet && frameCount > 30) {
                    baselineSkinPixels = totalSkinPixels;
                    emaBaseline = totalSkinPixels;
                    baselineSet = true;
                    debugInfo.textContent = `Hand detection: Ready (baseline: ${Math.round(baselineSkinPixels)})`;
                }
                
                // Hand detection logic (slightly stricter to reduce false triggers)
                const skinIncrease = totalSkinPixels - baselineSkinPixels;
                const deltaFromEma = totalSkinPixels - emaBaseline;
                const requiredDelta = Math.max(1200, emaBaseline * 0.28);
                const handCandidate = baselineSet &&
                    deltaFromEma > requiredDelta &&
                    handLikeRegions >= 2 &&
                    totalSkinPixels > 1000;
                
                if (handCandidate) {
                    consecutiveHandFrames++;
                } else {
                    consecutiveHandFrames = 0;
                    if (baselineSet) {
                        emaBaseline = emaAlpha * totalSkinPixels + (1 - emaAlpha) * emaBaseline;
                    }
                }
                
                const handDetected = consecutiveHandFrames >= 2 && (Date.now() - lastHandDetection > handDetectionCooldown);
                
                // Update debug info
                debugInfo.textContent = `Skin: ${Math.round(totalSkinPixels)} | EMA: ${Math.round(emaBaseline)} | ΔEMA:${Math.round(deltaFromEma)} | seq:${consecutiveHandFrames} | regions:${handLikeRegions}`;
                
                if (handDetected && Date.now() - lastHandDetection > handDetectionCooldown) {
                    handCount++;
                    if (handCounterEl) handCounterEl.textContent = String(handCount);
                    // Simplified: always trigger general scatter on hand detection
                    triggerScatter();
                    if (handCount % 3 === 0) {
                        growHalfFishBy(0.05);
                    }
                    // Every 10th hand: add stomach trash to two fish and glow
                    if (handCount % 10 === 0) {
                        addStomachTrashToTwoFish();
                    }
                    // At 200 hands, switch to Green-Yellow theme once
                    if (!appliedGreenThemeAt200 && handCount >= 200) {
                        appliedGreenThemeAt200 = true;
                        applyBackgroundGradient('green');
                    }
                    // At 500 hands, switch to Orange-Red theme once
                    if (!appliedOrangeThemeAt500 && handCount >= 500) {
                        appliedOrangeThemeAt500 = true;
                        applyBackgroundGradient('orange');
                    }
                        // Every 7th hand, trigger the poem overlay
                        if (handCount % 7 === 0) {
                            triggerPoemOverlay();
                        }
                    lastHandDetection = Date.now();
                    cameraStatus.textContent = 'Camera: Hand detected! ✋';
                    debugInfo.textContent = 'HAND DETECTED! Fish scattered!';
                    
                    setTimeout(() => {
                        if (handDetectionEnabled) {
                            cameraStatus.textContent = 'Camera: Active - Show hand to scatter fish!';
                        }
                    }, 2000);
                }
                

                
                requestAnimationFrame(detectHand);
            }
            
            detectHand();
        }
        
        function isImprovedSkinTone(r, g, b) {
            // More robust skin tone detection
            // Multiple skin tone ranges to account for different ethnicities
            
            // Condition 1: Traditional RGB skin detection
            const cond1 = (r > 95 && g > 40 && b > 20 && 
                          Math.max(r, g, b) - Math.min(r, g, b) > 15 &&
                          Math.abs(r - g) > 15 && r > g && r > b);
            
            // Condition 2: YCrCb color space approximation
            const y = 0.299 * r + 0.587 * g + 0.114 * b;
            const cr = 0.713 * (r - y);
            const cb = 0.564 * (b - y);
            const cond2 = (cr >= -25 && cr <= 25 && cb >= -15 && cb <= 15);
            
            // Condition 3: HSV-based detection
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            let h = 0;
            
            if (diff !== 0) {
                if (max === r) h = ((g - b) / diff) % 6;
                else if (max === g) h = (b - r) / diff + 2;
                else h = (r - g) / diff + 4;
                h = Math.round(h * 60);
                if (h < 0) h += 360;
            }
            
            const s = max === 0 ? 0 : diff / max;
            const v = max / 255;
            
            const cond3 = ((h >= 0 && h <= 50) || (h >= 300 && h <= 360)) && 
                         s >= 0.23 && s <= 0.68 && v >= 0.35;
            
            return cond1 || (cond2 && cond3);
        }
        


        // Apply a manual background gradient theme
        function applyBackgroundGradient(theme) {
            backgroundOverride = theme;
            selectedTheme = theme;
            forceRepaintBackground = true;
            if (theme === 'blue') {
                document.body.style.background = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)';
            } else if (theme === 'green') {
                document.body.style.background = 'linear-gradient(135deg, #2e7d32 0%, #f9a825 100%)';
            } else if (theme === 'orange') {
                document.body.style.background = 'linear-gradient(135deg, #fb8c00 0%, #c62828 100%)';
            }
        }
        
        function triggerScatter() {
            if (!isScattered) {
                isScattered = true;
                scatterTime = Date.now();
                status.textContent = 'Fish scattered! Regrouping in 3 seconds...';
                
                // Scatter all fish and create randomized water effects
                const effectMode = randomEffectMode();
                fish.forEach(f => {
                    f.scatter();
                    
                    // Randomized per-fish water effects (same mode for this trigger)
                    addWaterEffects(f.x, f.y, effectMode);
                });
                
                // Create some extra effects from random fish for dramatic effect (no random positions)
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const rf = fish[Math.floor(Math.random() * fish.length)];
                        if (rf) addWaterEffects(rf.x, rf.y, effectMode);
                    }, Math.random() * 500);
                }
            }
        }

        // Floating trash
        class FloatingTrash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 18 + 12;
                // Weighted selection favoring digital-themed items
                const types = ['gpu', 'battery', 'bottle', 'bag'];
                const weights = [0.4, 0.3, 0.2, 0.1];
                const r = Math.random();
                let acc = 0;
                for (let i = 0; i < types.length; i++) { acc += weights[i]; if (r <= acc) { this.type = types[i]; break; } }
                if (!this.type) this.type = 'gpu';
                this.vx = (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1);
                this.vy = Math.random() * 0.2 - 0.1;
                this.floatPhase = Math.random() * Math.PI * 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.01;
                this.opacity = 0.85;
            }
            update() {
                // gentle bobbing and drift
                this.x += this.vx + Math.sin(Date.now() * 0.001 + this.floatPhase) * 0.15;
                this.y += this.vy + Math.cos(Date.now() * 0.0012 + this.floatPhase) * 0.1;
                this.rotation += this.rotationSpeed;
                // wrap around horizontally, clamp vertically near surface
                if (this.x < -40) this.x = canvas.width + 40;
                if (this.x > canvas.width + 40) this.x = -40;
                this.y = Math.max(20, Math.min(canvas.height - 60, this.y));
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.opacity;
                if (this.type === 'gpu') {
                    // GPU-like board (stylized)
                    const w = this.size * 1.8;
                    const h = this.size * 1.0;
                    // PCB
                    ctx.fillStyle = '#1b5e20';
                    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(-w/2, -h/2, w, h, 4);
                    ctx.fill();
                    ctx.stroke();
                    // Edge connector (gold fingers)
                    ctx.fillStyle = '#d4af37';
                    ctx.fillRect(-w/2 + 6, h/2 - 6, w * 0.45, 4);
                    for (let i = 0; i < 6; i++) {
                        ctx.fillRect(-w/2 + 8 + i * (w*0.45/6), h/2 - 10, 3, 8);
                    }
                    // Main chip
                    ctx.fillStyle = '#111827';
                    ctx.fillRect(-w*0.15, -h*0.2, w*0.3, h*0.4);
                    // VRAM chips
                    ctx.fillStyle = '#374151';
                    const chipW = w * 0.18, chipH = h * 0.18;
                    ctx.fillRect(-w*0.45, -h*0.35, chipW, chipH);
                    ctx.fillRect(w*0.27, -h*0.35, chipW, chipH);
                    ctx.fillRect(-w*0.45, h*0.17, chipW, chipH);
                    ctx.fillRect(w*0.27, h*0.17, chipW, chipH);
                } else if (this.type === 'battery') {
                    // Battery (AA-like)
                    const w = this.size * 0.9;
                    const h = this.size * 2.0;
                    ctx.fillStyle = '#9ca3af';
                    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(-w/2, -h/2, w, h, 6);
                    ctx.fill();
                    ctx.stroke();
                    // Label band
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillRect(-w/2, -h*0.15, w, h*0.3);
                    // Terminals
                    ctx.fillStyle = '#111827';
                    ctx.fillRect(-w*0.2, -h/2 - 2, w*0.4, 4);
                    // Plus sign
                    ctx.fillStyle = '#111827';
                    ctx.fillRect(-2, -h*0.1 - 4, 4, 8);
                    ctx.fillRect(-6, -h*0.1 - 2, 12, 4);
                } else if (this.type === 'bottle') {
                    // bottle body
                    ctx.fillStyle = 'rgba(180, 220, 255, 0.65)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.5, this.size * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // bottle cap
                    ctx.fillStyle = '#3b82f6';
                    ctx.beginPath();
                    ctx.ellipse(0, -this.size * 0.95, this.size * 0.25, this.size * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // plastic bag
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.55)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.7, this.size * 0.4);
                    ctx.quadraticCurveTo(-this.size * 0.8, -this.size * 0.2, 0, -this.size * 0.6);
                    ctx.quadraticCurveTo(this.size * 0.8, -this.size * 0.2, this.size * 0.7, this.size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // bag handles hint
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.3, -this.size * 0.4);
                    ctx.quadraticCurveTo(-this.size * 0.15, -this.size * 0.65, 0, -this.size * 0.55);
                    ctx.quadraticCurveTo(this.size * 0.15, -this.size * 0.65, this.size * 0.3, -this.size * 0.4);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        function triggerScatterSide(side) {
            const now = Date.now();
            if (now - lastSideScatter < sideScatterCooldown) return;
            lastSideScatter = now;
            const duration = 3000;
            const thirdX = canvas.width / 3;
            const twoThirdX = 2 * thirdX;
            const isLeft = side === 'left';
            status.textContent = isLeft ? 'Left side splash!' : 'Right side splash!';
            
            const effectMode = randomEffectMode();
            fish.forEach(f => {
                const inTargetThird = isLeft ? (f.x < thirdX) : (f.x >= twoThirdX);
                const bleedFromOtherZones = !inTargetThird && Math.random() < 0.15; // small bleed for "mostly"
                if (inTargetThird || bleedFromOtherZones) {
                    f.scatter();
                    f.scatterUntil = now + duration;
                    addWaterEffects(f.x, f.y, effectMode);
                }
            });
            
            // Extra effects confined to the target half (originating from fish only)
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const candidates = fish.filter(ff => isLeft ? (ff.x < thirdX) : (ff.x >= twoThirdX));
                    const pool = candidates.length ? candidates : fish;
                    const chosen = pool[Math.floor(Math.random() * pool.length)];
                    if (chosen) addWaterEffects(chosen.x, chosen.y, effectMode);
                }, Math.random() * 500);
            }
        }

        function triggerScatterLeft() {
            triggerScatterSide('left');
        }

        function triggerScatterRight() {
            triggerScatterSide('right');
        }
        
        // Animation loop
        function animate() {
            // Clear canvas background using theme gradient with yellow tint overlay
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            const colors = themeGradients[selectedTheme] || themeGradients.blue;
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(1, colors[1]);
            ctx.save();
            if (forceRepaintBackground) {
                ctx.globalAlpha = 1.0; // immediate repaint on theme change
                forceRepaintBackground = false;
            } else {
                ctx.globalAlpha = 0.1; // motion blur fade
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Apply subtle yellow tint that accumulates
            if (yellowTintStrength > 0) {
                ctx.globalAlpha = Math.min(0.12, yellowTintStrength);
                ctx.fillStyle = '#ffd54f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.restore();
            
            // Update group angle: gentle oscillation (reduces perpetual spinning)
            groupAngle = Math.sin(Date.now() * 0.0005) * 0.8;
            
            // Check if scatter time is over
            if (isScattered && Date.now() - scatterTime > 3000) {
                isScattered = false;
                status.textContent = 'Fish regrouping...';
                setTimeout(() => {
                    if (!isScattered) {
                        status.textContent = 'Fish swimming in formation';
                    }
                }, 1000);
            }
            
            // Update and draw fish
            fish.forEach((f, index) => {
                f.update(isScattered, groupAngle, fish);
                f.draw();
                // Draw abstract trash inside fish stomachs (accumulating)
                const items = stomachTrashByFish.get(index);
                if (items && items.length) {
                    const now = Date.now();
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.angle);
                    items.forEach((it, idx) => {
                        const base = f.size * it.sizeScale;
                        const pulse = 0.9 + Math.sin(now * it.pulseSpeed + idx) * 0.08;
                        const sx = f.size * it.offsetXScale;
                        const sy = f.size * it.offsetYScale;
                        const s = base * pulse;
                        ctx.save();
                        ctx.translate(sx, sy);
                        ctx.rotate(it.rotation + Math.sin(now * it.pulseSpeed) * 0.1);
                        if (it.type === 'ring') {
                            ctx.globalAlpha = 0.85;
                            ctx.strokeStyle = it.colorA;
                            ctx.lineWidth = Math.max(1.5, s * 0.18);
                            ctx.beginPath();
                            ctx.ellipse(0, 0, s * 0.8, s * 0.5, 0.2, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 0.6;
                            ctx.strokeStyle = it.colorB;
                            ctx.lineWidth *= 0.6;
                            ctx.stroke();
                        } else if (it.type === 'shard') {
                            ctx.globalAlpha = 0.9;
                            ctx.fillStyle = it.colorA;
                            ctx.beginPath();
                            ctx.moveTo(-s * 0.6, -s * 0.2);
                            ctx.lineTo(s * 0.4, -s * 0.05);
                            ctx.lineTo(s * 0.2, s * 0.45);
                            ctx.lineTo(-s * 0.5, s * 0.15);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 0.75;
                            ctx.fillStyle = it.colorB;
                            ctx.beginPath();
                            ctx.ellipse(-s * 0.1, s * 0.05, s * 0.2, s * 0.08, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (it.type === 'chip') {
                            ctx.globalAlpha = 0.85;
                            ctx.fillStyle = it.colorA;
                            ctx.beginPath();
                            ctx.roundRect(-s * 0.45, -s * 0.3, s * 0.9, s * 0.6, s * 0.12);
                            ctx.fill();
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = it.colorB;
                            for (let q = -1; q <= 1; q++) {
                                ctx.fillRect(-s * 0.25 + q * s * 0.2, -s * 0.1, s * 0.12, s * 0.22);
                            }
                        } else { // cluster
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = it.colorA;
                            for (let b = 0; b < 5; b++) {
                                const da = (b * 2.399) + idx * 0.3;
                                const rx = Math.cos(da) * s * 0.4;
                                const ry = Math.sin(da) * s * 0.25;
                                ctx.beginPath();
                                ctx.arc(rx, ry, s * 0.18, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = it.colorB;
                            ctx.beginPath();
                            ctx.arc(0, 0, s * 0.22, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                    ctx.restore();
                }
            });
            
            // Update and draw water effects
            for (let i = waterEffects.length - 1; i >= 0; i--) {
                if (!waterEffects[i].update()) {
                    waterEffects.splice(i, 1);
                } else {
                    waterEffects[i].draw();
                }
            }

            // Update and draw floating trash
            for (let i = 0; i < trashItems.length; i++) {
                trashItems[i].update();
                trashItems[i].draw();
            }
            
            // Add some bubbles for atmosphere
            if (Math.random() < 0.1) {
                drawBubble();
            }
            
            requestAnimationFrame(animate);
        }
        
        function drawBubble() {
            const x = Math.random() * canvas.width;
            const y = canvas.height;
            const size = Math.random() * 10 + 5;
            
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#87ceeb';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'd') {
                document.body.classList.add('hidden-ui');
            } else if (key === 'a') {
                document.body.classList.remove('hidden-ui');
            } else if (key === 'f') {
                // Simulate +10 hand detections and trigger growth effect
                handCount += 10;
                if (handCounterEl) handCounterEl.textContent = String(handCount);
                growHalfFishBy(0.05);
                triggerScatter();
                if (!appliedGreenThemeAt200 && handCount >= 200) {
                    appliedGreenThemeAt200 = true;
                    applyBackgroundGradient('green');
                }
                if (!appliedOrangeThemeAt500 && handCount >= 500) {
                    appliedOrangeThemeAt500 = true;
                    applyBackgroundGradient('orange');
                }
            } else if (key === 'z') {
                // Trigger same overlay flow as 'z'
                triggerPoemOverlay();
            }
            if (key === 'j') {
                triggerScatterLeft();
            } else if (key === 'l') {
                triggerScatterRight();
            } else if (key === 'k') {
                triggerScatter();
            } else if (key === 'o') {
                addStomachTrashToTwoFish();
            } else if (key === 't') {
                // Add more floating trash each press
                for (let i = 0; i < trashAddCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * Math.min(220, canvas.height * 0.4);
                    trashItems.push(new FloatingTrash(x, y));
                }
                // Keep spawn amount fixed and increase yellow tint subtly
                yellowTintStrength = Math.min(yellowTintStrength + 0.015, 0.12);
            }
        });
        
        // Theme button handlers
        btnBlue.addEventListener('click', () => applyBackgroundGradient('blue'));
        btnGreen.addEventListener('click', () => applyBackgroundGradient('green'));
        btnOrange.addEventListener('click', () => applyBackgroundGradient('orange'));
        
        // Camera selection change handler
        cameraSelect.addEventListener('change', (e) => {
            const selectedDeviceId = e.target.value;
            if (selectedDeviceId) {
                startCamera(selectedDeviceId);
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Start animation and camera
        animate();
        initializeCamera();

        // Capture a frame helpers
        function captureFrameAsBlob() {
            return new Promise((resolve, reject) => {
                try {
                    const off = document.createElement('canvas');
                    off.width = video.videoWidth || 320;
                    off.height = video.videoHeight || 240;
                    const ox = off.getContext('2d');
                    ox.drawImage(video, 0, 0, off.width, off.height);
                    off.toBlob((blob) => {
                        if (blob) resolve(blob); else reject(new Error('Failed to capture frame'));
                    }, 'image/jpeg', 0.9);
                } catch (e) { reject(e); }
            });
        }
        function captureFrameDataUrl() {
            const off = document.createElement('canvas');
            off.width = video.videoWidth || 320;
            off.height = video.videoHeight || 240;
            const ox = off.getContext('2d');
            ox.drawImage(video, 0, 0, off.width, off.height);
            return off.toDataURL('image/jpeg', 0.9);
        }

        // Create a short, fun poem (<= 30 words) from a fish's perspective
        // Avoid mentioning "box"; base on fullness and plastic/stone/other ratios
        function makePoem(fullness, stone, plastic, other) {
            const f = (typeof fullness === 'number') ? fullness : null;
            const s = (typeof stone === 'number') ? stone : 0;
            const p = (typeof plastic === 'number') ? plastic : 0;
            const o = (typeof other === 'number') ? other : 0;
            const sum = Math.max(1, s + p + o);
            const pr = p / sum, sr = s / sum, orr = o / sum;
            const fullnessLine = (() => {
                if (f == null) return 'Unknown currents ripple; I hover, listening.';
                if (f >= 90) return 'Crowded water presses; I dart between';
                if (f >= 60) return 'Restless currents; I circle past';
                if (f >= 30) return 'Quiet swells; I glide beside';
                return 'Wide blue; I wander through';
            })();
            const dominant = (pr > sr && pr > orr) ? 'plastic' : (sr > pr && sr > orr) ? 'stone' : (orr > 0 ? 'odd drifting things' : 'mixed drifting things');
            const domPhrase = (dominant === 'plastic') ? 'bitter glitter of plastic' : (dominant === 'stone') ? 'the cool hush of stone' : dominant;
            const feeling = (() => {
                if (pr > 0.6) return 'I ache; home tastes wrong.';
                if (pr > 0.35) return 'I fret, yet keep weaving.';
                if (sr > 0.6) return 'I rest; stones steady me.';
                return 'I breathe easy, dreaming bubbles.';
            })();
            return `${fullnessLine} ${domPhrase}. ${feeling}`;
        }

        async function analyzeFromCamera() {
            fullnessOutput.textContent = 'Analyzing...';
            try {
                // Try Vercel serverless function first
                const dataUrl = captureFrameDataUrl();
                // Show snapshot while analyzing
                snapshotImg.src = dataUrl;
                snapshotImg.style.display = 'block';
                await new Promise(r => (snapshotImg.onload = r));
                snapshotCanvas.width = snapshotImg.naturalWidth;
                snapshotCanvas.height = snapshotImg.naturalHeight;
                snapshotCanvas.style.width = snapshotImg.clientWidth + 'px';
                snapshotCanvas.style.height = snapshotImg.clientHeight + 'px';
                snapshotCanvas.style.display = 'block';
                snapshotCtx.clearRect(0, 0, snapshotCanvas.width, snapshotCanvas.height);
                let res = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ imageBase64: dataUrl })
                });
                let data = await res.json().catch(() => null);
                if (!res.ok && res.status === 404) {
                    // Fallback to local Express route
                    const blob = await captureFrameAsBlob();
                    const form = new FormData();
                    form.append('image', blob, 'frame.jpg');
                    res = await fetch('/analyze', { method: 'POST', body: form });
                    data = await res.json().catch(() => null);
                }
                if (!res.ok) {
                    const msg = (data && data.error) ? data.error : `Server error: ${res.status}`;
                    throw new Error(msg);
                }
                if (data) {
                    const { fullness, stone, plastic, other, reasons, outputFormat, raw } = data;
                    const poem = makePoem(fullness, stone, plastic, other);
                    const out = [poem];
                    if (raw) {
                        out.push('', 'Raw output:', String(raw));
                    }
                    fullnessOutput.textContent = out.join('\n');
                    // Draw overlay on snapshot
                    if (typeof fullness === 'number') {
                        snapshotCtx.save();
                        const fillTopPx = Math.max(0, Math.round(snapshotCanvas.height * (1 - fullness / 100)));
                        const fillHeightPx = snapshotCanvas.height - fillTopPx;
                        snapshotCtx.fillStyle = 'rgba(0, 150, 255, 0.25)';
                        snapshotCtx.fillRect(0, fillTopPx, snapshotCanvas.width, fillHeightPx);
                        snapshotCtx.strokeStyle = 'rgba(0, 150, 255, 0.9)';
                        snapshotCtx.lineWidth = 3;
                        snapshotCtx.beginPath();
                        snapshotCtx.moveTo(0, fillTopPx);
                        snapshotCtx.lineTo(snapshotCanvas.width, fillTopPx);
                        snapshotCtx.stroke();
                        snapshotCtx.restore();
                    }
                } else {
                    fullnessOutput.textContent = 'No result returned.';
                }
            } catch (err) {
                console.error(err);
                fullnessOutput.textContent = err && err.message ? err.message : 'Error analyzing image.';
            }
        }

        // Shared poem overlay trigger (used by 'z' and hand-count multiples of 7)
        async function triggerPoemOverlay() {
            let poem = '';
            try { poem = await analyzeForPoemOnly() || ''; } catch (_) { poem = ''; }
            if (!poem) poem = 'I tried to speak, but currents tangled my words.';
            const words = poem.split(/(\s+)/);
            centerMessageText.innerHTML = '';
            words.forEach((w) => {
                const span = document.createElement('span');
                span.className = 'word';
                span.textContent = w;
                centerMessageText.appendChild(span);
            });
            centerMessageText.classList.remove('show');
            centerMessageText.classList.add('boost');
            // Restart animation
            // eslint-disable-next-line no-unused-expressions
            centerMessageText.offsetWidth;
            centerMessageText.style.setProperty('--fade-dur', '15s');
            centerMessageText.style.animationDuration = '15s';
            centerMessageText.classList.add('show');
            centerMessageText.classList.add('ripple');
            // Start word fly-away at ~12s
            setTimeout(() => {
                const spans = centerMessageText.querySelectorAll('.word');
                spans.forEach((span) => {
                    if (!span.textContent || /^\s+$/.test(span.textContent)) return;
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 40 + Math.random() * 120;
                    const tx = Math.cos(angle) * dist;
                    const ty = Math.sin(angle) * dist;
                    const rot = (Math.random() * 40 - 20) + 'deg';
                    const dur = (2.4 + Math.random() * 1.2) + 's';
                    const delay = (Math.random() * 0.5) + 's';
                    span.style.setProperty('--tx', tx + 'px');
                    span.style.setProperty('--ty', ty + 'px');
                    span.style.setProperty('--rot', rot);
                    span.style.setProperty('--fly-dur', dur);
                    span.style.setProperty('--fly-delay', delay);
                    span.classList.add('fly');
                });
            }, 12000);
            // Cleanup after 15s
            setTimeout(() => {
                centerMessageText.classList.remove('show');
                centerMessageText.classList.remove('boost');
                centerMessageText.classList.remove('ripple');
                centerMessageText.style.animationDuration = '';
                centerMessageText.style.removeProperty('--fade-dur');
                centerMessageText.innerHTML = '';
            }, 15000);
        }

        // Helper used by 'z' key to return poem only (no UI updates)
        async function analyzeForPoemOnly() {
            try {
                const dataUrl = captureFrameDataUrl();
                let res = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ imageBase64: dataUrl })
                });
                let data = await res.json().catch(() => null);
                if (!res.ok && res.status === 404) {
                    const blob = await captureFrameAsBlob();
                    const form = new FormData();
                    form.append('image', blob, 'frame.jpg');
                    res = await fetch('/analyze', { method: 'POST', body: form });
                    data = await res.json().catch(() => null);
                }
                if (!res.ok) return null;
                if (!data) return null;
                const { fullness, stone, plastic, other } = data;
                return makePoem(fullness, stone, plastic, other);
            } catch {
                return null;
            }
        }

        btnAnalyze.addEventListener('click', analyzeFromCamera);
  </script>
</body>
</html>